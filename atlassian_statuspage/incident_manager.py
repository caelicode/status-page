#!/usr/bin/env python3

import logging
from datetime import datetime, timezone
from typing import Optional

from atlassian_statuspage.client import StatuspageClient, StatuspageError

logger = logging.getLogger(__name__)

COMPONENT_STATUS_MAP = {
    "operational": "operational",
    "degraded_performance": "degraded_performance",
    "major_outage": "major_outage",
}

STATUS_TO_IMPACT = {
    "degraded_performance": "minor",
    "major_outage": "critical",
}

STATUS_DISPLAY = {
    "degraded_performance": "degraded performance",
    "major_outage": "a major outage",
}


def find_open_incident_for_component(
    unresolved_incidents: list, component_id: str
) -> Optional[dict]:
    for incident in unresolved_incidents:
        affected_ids = []
        for comp in incident.get("components", []):
            affected_ids.append(comp.get("id", ""))
        if component_id in affected_ids:
            return incident
    return None


def generate_incident_name(component_name: str, status: str) -> str:
    description = STATUS_DISPLAY.get(status, "issues")
    return f"{component_name} experiencing {description}"


def generate_incident_body(
    component_name: str, status: str, reachability: Optional[float], latency: Optional[float]
) -> str:
    now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    lines = [f"**{now}** — Automated monitoring detected an issue with **{component_name}**."]

    metrics = []
    if reachability is not None:
        metrics.append(f"Reachability: {reachability:.1f}%")
    if latency is not None:
        metrics.append(f"Latency: {latency:.0f}ms")
    if metrics:
        lines.append(f"Current metrics: {', '.join(metrics)}.")

    if status == "degraded_performance":
        lines.append("The service is experiencing degraded performance. We are investigating.")
    elif status == "major_outage":
        lines.append("The service is experiencing a major outage. We are investigating.")

    return "\n\n".join(lines)


def generate_resolve_body(component_name: str) -> str:
    now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    return (
        f"**{now}** — **{component_name}** has returned to normal operation. "
        f"All systems are operational. This incident has been resolved."
    )


def generate_postmortem(
    incident: dict, component_name: str, resolve_time: str
) -> str:
    created = incident.get("created_at", "unknown")
    if isinstance(created, str) and "T" in created:
        try:
            created_dt = datetime.fromisoformat(created.replace("Z", "+00:00"))
            created = created_dt.strftime("%Y-%m-%d %H:%M UTC")
        except (ValueError, TypeError):
            pass

    name = incident.get("name", "Incident")
    impact = incident.get("impact", "unknown")

    updates = incident.get("incident_updates", [])
    timeline_lines = []
    for update in reversed(updates):
        update_status = update.get("status", "update")
        update_body = update.get("body", "")
        update_time = update.get("created_at", "")
        if isinstance(update_time, str) and "T" in update_time:
            try:
                ut = datetime.fromisoformat(update_time.replace("Z", "+00:00"))
                update_time = ut.strftime("%Y-%m-%d %H:%M UTC")
            except (ValueError, TypeError):
                pass
        timeline_lines.append(f"- **{update_time}** [{update_status}]: {update_body}")

    timeline = "\n".join(timeline_lines) if timeline_lines else "- No detailed updates recorded."

    return f"""## Postmortem: {name}

### Summary

**Component:** {component_name}
**Impact:** {impact}
**Started:** {created}
**Resolved:** {resolve_time}

This incident was automatically detected by our monitoring system and resolved when services returned to normal operation.

### Timeline

{timeline}

### Root Cause

This incident was detected via automated monitoring. The root cause was identified as a service degradation that was automatically resolved. If further investigation is needed, a manual follow-up will be added.

### Resolution

The service returned to normal operation and was automatically marked as resolved by our monitoring system.

### Preventive Measures

- Continuous automated monitoring remains active
- Alerting thresholds are reviewed periodically
- This postmortem was auto-generated and may be updated with additional details

---
*This postmortem was automatically generated by the status page monitoring system.*
"""


def process_incidents(
    client: StatuspageClient,
    component_mapping: dict,
    status_report: dict,
    auto_incidents: bool = True,
    auto_postmortem: bool = True,
    notify_subscribers: bool = True,
) -> dict:
    result = {"created": [], "updated": [], "resolved": [], "errors": []}

    if not auto_incidents:
        logger.info("Incident automation is disabled — skipping")
        return result

    try:
        unresolved = client.list_unresolved_incidents()
    except StatuspageError as e:
        logger.error("Failed to fetch unresolved incidents: %s", e)
        result["errors"].append(f"Failed to fetch unresolved incidents: {e}")
        return result

    logger.info("Found %d unresolved incidents on Statuspage", len(unresolved))

    components_data = {
        comp["name"]: comp for comp in status_report.get("components", [])
    }

    for job_label, mapping in component_mapping.items():
        component_id = mapping.get("component_id")
        component_name = mapping.get("name", job_label)

        if not component_id:
            continue

        comp_data = components_data.get(component_name)
        if not comp_data:
            logger.debug("No status data for '%s' — skipping incident check", component_name)
            continue

        current_status = COMPONENT_STATUS_MAP.get(
            comp_data["status"], "major_outage"
        )
        reachability = comp_data.get("reachability")
        latency = comp_data.get("latency_ms")
        is_healthy = current_status == "operational"

        open_incident = find_open_incident_for_component(unresolved, component_id)

        if not is_healthy and open_incident is None:
            incident_name = generate_incident_name(component_name, current_status)
            incident_body = generate_incident_body(
                component_name, current_status, reachability, latency
            )
            impact = STATUS_TO_IMPACT.get(current_status, "minor")

            try:
                new_incident = client.create_incident(
                    name=incident_name,
                    status="investigating",
                    body=incident_body,
                    component_ids=[component_id],
                    components={component_id: current_status},
                    deliver_notifications=notify_subscribers,
                    impact_override=impact,
                )
                incident_id = new_incident.get("id", "unknown")
                logger.info(
                    "Created incident '%s' (ID: %s) for %s",
                    incident_name, incident_id, component_name,
                )
                result["created"].append({
                    "component": component_name,
                    "incident_id": incident_id,
                    "status": current_status,
                })
            except StatuspageError as e:
                logger.error("Failed to create incident for %s: %s", component_name, e)
                result["errors"].append(f"Create incident for {component_name}: {e}")

        elif not is_healthy and open_incident is not None:
            incident_id = open_incident["id"]
            update_body = generate_incident_body(
                component_name, current_status, reachability, latency
            )
            new_impact = STATUS_TO_IMPACT.get(current_status, "minor")
            old_impact = open_incident.get("impact", "minor")
            impact_escalated = new_impact != old_impact
            new_name = generate_incident_name(component_name, current_status)

            try:
                client.update_incident(
                    incident_id=incident_id,
                    status="identified",
                    body=update_body,
                    components={component_id: current_status},
                    deliver_notifications=impact_escalated and notify_subscribers,
                    impact_override=new_impact,
                    name=new_name,
                )
                if impact_escalated:
                    logger.info(
                        "Escalated incident %s for %s from %s to %s",
                        incident_id, component_name, old_impact, new_impact,
                    )
                else:
                    logger.info(
                        "Updated incident %s for %s (still %s)",
                        incident_id, component_name, current_status,
                    )
                result["updated"].append({
                    "component": component_name,
                    "incident_id": incident_id,
                    "status": current_status,
                    "escalated": impact_escalated,
                })
            except StatuspageError as e:
                logger.error("Failed to update incident %s: %s", incident_id, e)
                result["errors"].append(f"Update incident {incident_id}: {e}")

        elif is_healthy and open_incident is not None:
            incident_id = open_incident["id"]
            resolve_body = generate_resolve_body(component_name)
            resolve_time = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")

            try:
                client.resolve_incident(
                    incident_id=incident_id,
                    body=resolve_body,
                    components={component_id: "operational"},
                    deliver_notifications=notify_subscribers,
                )
                logger.info(
                    "Resolved incident %s for %s",
                    incident_id, component_name,
                )
                result["resolved"].append({
                    "component": component_name,
                    "incident_id": incident_id,
                })
            except StatuspageError as e:
                logger.error("Failed to resolve incident %s: %s", incident_id, e)
                result["errors"].append(f"Resolve incident {incident_id}: {e}")
                continue

            if auto_postmortem:
                try:
                    incidents = client.list_incidents()
                    full_incident = None
                    for inc in incidents:
                        if inc.get("id") == incident_id:
                            full_incident = inc
                            break

                    if full_incident is None:
                        full_incident = open_incident

                    postmortem_body = generate_postmortem(
                        full_incident, component_name, resolve_time
                    )
                    client.create_postmortem(
                        incident_id=incident_id,
                        body=postmortem_body,
                        notify_subscribers=notify_subscribers,
                        notify_twitter=False,
                    )
                    logger.info(
                        "Published postmortem for incident %s (%s)",
                        incident_id, component_name,
                    )
                except StatuspageError as e:
                    logger.warning(
                        "Failed to create postmortem for incident %s: %s "
                        "(incident was resolved successfully)",
                        incident_id, e,
                    )
                    result["errors"].append(
                        f"Postmortem for incident {incident_id}: {e}"
                    )

    return result
